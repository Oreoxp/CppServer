# 跳表

[TOC]

​		在 leveldb 中，我们定期从读取内存、从内存写入磁盘、从磁盘读取到内存，因此我们需要一个高效的数据结构：

1. 高效查找
2. 高效插入
3. 高效顺序遍历

相关论文： [skiplists (cmu.edu)](https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf) 里面提到：

>  Skip lists are a data structure that can be used in place of balanced trees.
> Skip lists use probabilistic balancing rather than strictly enforced balancing and as a result the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.
> 跳表是一种可以取代平衡树的数据结构。
> 跳表使用概率均衡而非严格均衡策略，从而相对于平衡树，大大简化和加速了元素的插入和删除。 



## 链表到跳表

​		简言之，**跳表就是带有额外指针的链表**。为了理解这个关系，我们来思考一下优化有序链表查找性能的过程。

​		假设我们有个有序链表，可知其查询和插入复杂度都为 O(n)。相比数组，链表不能进行二分查找的原因在于，不能用下标索引进行常数复杂度数据访问，从而不能每次每次快速的筛掉现有规模的一半。那么如何改造一下链表使之可以进行二分？

​		利用 map 构造一个下标到节点的映射？这样虽然可以进行二分查询了，但是每次插入都会引起后面所有元素的下标变动，从而需要在 map 中进行 O(n) 的更新。

​		增加指针使得从任何一个节点都能直接跳到其他节点？那得构造一个全连接图，指针耗费太多空间不说，每次插入指针的更新仍是 O(n) 的。

​		跳表给出了一种思路，**跳步采样，构建索引，逐层递减**。下面利用论文中的一张图来详细解释下。

![other_skiplistgen](.\markdownimage\other_skiplistgen.png)



​		如上图，初始我们有个带头结点的有序链表 a，其查找复杂度为 O(n)。然后，我们进行跳步采样，将采样出的节点按用指针依次串联上，得到表 b，此时的查找复杂度为 O(log *n*/2 + 1) 。其后，我们在上次采样出的节点，再次进行跳步采样，并利用指针依次串联上，得到表 c，此时的查找复杂为 O(log 2*n*/4 + 2)。此后，我们重复这个跳步采样、依次串联的过程，直到采样出的节点只剩一个，如图 e，此时的查找复杂度，可以看出为 O(log 2n) 。

​		代价是我们增加了一堆指针，增加了多少呢？我们来逐次考虑这个问题。从图中可以看出，每次采样出多少节点，便会增加多少个指针；我们的采样策略是，每次在上一次的节点集中间隔采样，初始节点数为 n，最后采到只剩一个节点为止。将其加和则为：(n/2 + n/4 + ... + 1) = n。这和一个节点为 n 的二叉树的指针数是相同的。

​		这里我们回避了一个问题：该结构的插入时间复杂度是多少？这其实进一步了引出本质问题，我们该如何进行插入。

## 跳表和平衡树

​		在实践中，我们常用搜索二叉树作为字典表或者顺序表。在插入过程中，如果数据在 key 空间具有很好地随机性，那么二叉搜索树每次顺序插入就可以维持很好的查询性能。但如果我们顺序的插入数据，则会使得二叉搜索树严重失衡，从而使读写性能都大幅度退化。

​		为了保证性能，需要在发现不平衡时进行调整，于是有了 AVL 树和红黑树。众所周知，AVL 的旋转策略和红黑树的标色策略都稍显复杂，反正我粗看了两次都没记住，面试手撸更是不可能。

​		而跳表在保证同样查询效率的情况下，使用了一种很巧妙的转化，大大简化了插入的实现。我们不能保证所有的插入请求在 key 空间具有很好地随机性，或者说均衡性；但我们可以控制每个节点其他维度的均衡性。比如，跳表中每个节点的指针数分布的概率均衡。

## 概率均衡

​		为了更好地讲清楚这个问题，我们梳理一下跳表的结构和所涉及到概念。跳表每个节点都会有 1 ~ MaxLevel 个指针，有 k 个指针的节点称为 *k 层节点*（level k node）；所有节点的层次数的最大值为跳表的*最大层数*（MaxLevel）。跳表带有一个空的头结点，头结点有 MaxLevel 个指针。

​		按前面从有序链表构建跳表的思路，每次插入新节点就变成了难题，比如插入的节点需要有多少个指针？插入后如何才能保证查找性能不下降（即维持采样的均衡）？

​		为了解决这个问题， Pugh 进行了一个巧妙的转化：将**全局、静态**的构建索引拆解为**独立、动态**的构建索引。其中的关键在于**<u>通过对跳表全局节点指针数概率分布的维持，达到对查询效率的保持</u>**。分析上面见索引逐层采样的过程我们可以发现，建成的跳表中有 50% 的节点为 1 层节点，25% 的节点为 2 层节点，12.5% 的节点为三层节点，依次类推。若能维持我们构造的跳表中的节点具有同样的概率分布，就能保证差不多查询性能。这在直觉上似乎没问题，这里不去深入探讨背后的数学原理，感兴趣的同学可以去读一读论文。

经过这样的转化，就解决了上面提出的两个问题：

1. 插入新节点的指针数通过独立的计算一个概率值决定，使全局节点的指针数满足几何分布即可。
2. 插入时不需要做额外的节点调整，只需要先找到其需要放的位置，然后修改他和前驱的指向即可。

这样插入节点的时间复杂度为查找的时间复杂度 `O(log2n)`，与修改指针的复杂度 `O(1)` 之和，即也为 `O(log2n)`，删除过程和插入类似，也可以转化为查找和修改指针值，因此复杂度也为 `O(log2n)`。







































