[TOC]



# 基础组件

## 一、Slice

Leveldb 中的基本数据结构：

1. 包括 length 和一个指向外部字节数组的指针。
2. 和 string 一样，允许字符串中包含 ’\0’。

​        提供一些基本接口，可以把 const char 和 string 转换为 Slice；把 Slice 转换 为string，取得数据指针 const char。





## 二、satus

​		Leveldb 中的**返回状态**，将错误号和错误信息封装成 Status 类，统一进行处理。并定义了几种具体的返回状态，如成功或者文件不存在等。

​		为了节省空间 Status 并没有用 std::string 来**存储错误信息**，而是将返回码(code), 错误信息 message 及长度打包存储于一个字符串数组中。

成功状态OK 是 NULL state_ ，否则 state_ 是一个包含如下信息的数组:

```
state_[0..3] == 消息 message 长度 
state_[4]    == 消息 code
state_[5..]  == 消息 message 
```





## 三、Arena

​		leveldb 的简单的内存池，它所作的工作十分简单，申请内存时，将申请到的内存块放入 std::vector blocks_中，在 Arena 的生命周期结束后，统一释放掉所有申请到的内存，内部结构如下图所示。

![01arena](.\markdownimage\01arena.png)



​		**Arena主要提供了两个申请函数**：其中一个直接分配内存，另一个可以申请对齐的内存空间。

​		<u>Arena 没有直接调用 delete/free 函数</u>，而是由 Arena 的析构函数统一释放所有的内存。应该说这是和 leveldb 特定的应用场景相关的，比如一个 memtable 使用一个Arena，当 memtable 被释放时，<u>由 Arena 统一释放其内存。</u>



## 四、Skip list

​		**Skip list(跳跃表）是一种可以代替平衡树的数据结构。**Skip lists 应用概率保证平衡，平衡树采用严格的旋转（比如平衡二叉树有左旋右旋）来保证平衡，因此 Skip list 比较容易实现，而且相比平衡树有着较高的运行效率。

​		从概率上保持数据结构的平衡比显式的保持数据结构平衡要简单的多。**对于大多数应用，用 skip list 要比用树更自然，算法也会相对简单**。由于 skip list 比较简单，实现起来会比较容易，虽然和平衡树有着相同的时间复杂度(O(logn))，但是 skip list 的常数项相对小很多。skip list 在空间上也比较节省。一个节点平均只需要 1.333 个指针（甚至更少），并且不需要存储保持平衡的变量。

![other_skiplist](.\markdownimage\other_skiplist.png)



























