[TOC]

# MySQL 架构与查询

![01 mysql架构图](./markdownimage/01 mysql架构图.png)

​		MySql 大概分为两层：server层和存储引擎层。我们从一条查询 SQL 语句开始逐层分析：

```mysql
select * from T where ID=10；
```



## 1、Server - 连接器

​		第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。**<u>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</u>**

​		连接命令一般是这么写的：

```mysql
mysql -h$ip -P$port -u$user -p
```

​		连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。

### 查询缓存

​		连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。<u>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。</u>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。

​		如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。

​		<u>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中</u>。

​		你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。但是大多数情况下我会建议你不要使用查询缓存，为什么呢？**<u>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。</u>**对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

​		MySQL 可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。

​		而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

```mysql
mysql> select SQL_CACHE * from T where ID=10；
```



## 2、Server-分析器

​		在分析器中，Mysql会进行词法分析、语法分析等，这样Mysql才知道你要做啥。在分析阶段判断语句是否正确，表是否存在，列是否存在等。

## 3、Server-优化器

​		优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

​		比如你执行下面这样的语句，这个语句是执行两个表的 join：

```mysql
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

即可以先判断   t1.c =10   也可以先判断   t2.d = 20。

这两个判断的结果肯定一样，但效率会有不同，最终由优化器确定。

## 4、Server-执行器

​		执行器负责执行。执行前都会确定权限，之后根据不同的引擎调用不同的接口，Mysql 默认 innodb。

​		比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了。

​		对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。

​		你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。

​		这个值就是在执行器每次调用引擎获取数据行的时候累加的。

​		在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。





[TOC]



# MySql 日志系统与更新

​		我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c：

```mysql
mysql> create table T(ID int primary key, c int);
```

如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：

```mysql
mysql> update T set c=c+1 where ID=2;
```

查询语句的那一套流程，更新语句也是同样会走一遍。

![01 mysql架构图](./markdownimage/01 mysql架构图.png)















